# Kristers Katkevics-Cirkovs, Anton Molchanov

# Used for making HTTP requests to the API.
import requests
# Used for generating random numbers for exploration coordinates.
import random
# Used for writing data to CSV files (explore and moves logs).
import csv
# Used for parsing command-line arguments (like the API base URL and student names).
import argparse
# Used for type hinting, improving code readability and maintainability.
from typing import List, Tuple, Optional, Dict
# Specifically import JSONDecodeError for handling cases where API response isn't valid JSON.
from requests.exceptions import JSONDecodeError

# Total number of random exploration steps allowed.
EXPLORE_STEPS = 200
# Total number of exploitation steps (including the starting point).
EXPLOIT_STEPS = 10
# Minimum and maximum boundaries for x and y coordinates during exploration (using floats).
X_MIN, X_MAX = -100.0, 100.0
Y_MIN, Y_MAX = -100.0, 100.0
# Minimum and maximum boundaries for x and y coordinates during exploitation (using integers).
# Defined separately for clarity and strict checking of integer exploitation moves.
INT_X_MIN, INT_X_MAX = -100, 100
INT_Y_MIN, INT_Y_MAX = -100, 100
# Maximum time (in seconds) to wait for a response from the API before giving up.
TIMEOUT_SECONDS = 5

# Defines a type alias 'Coord' representing a coordinate pair (float, float).
Coord = Tuple[float, float]
# Defines a type alias 'IntCoord' representing an integer coordinate pair (int, int).
IntCoord = Tuple[int, int]
# Defines a type alias 'ExploredPoint' representing a point found during exploration (x, y, z).
ExploredPoint = Tuple[float, float, float] # x, y, z

def get_port_from_url(url: str) -> Optional[str]:
    """
    Extracts the port number (as a string) from a URL string.
    Handles URLs with or without trailing slashes and paths.
    Returns None if no port is found or if the extracted part is not digits.
    """
    try:
        # Find the end of the scheme (e.g., "http://")
        scheme_end = url.find('://')
        if scheme_end == -1: scheme_end = 0 # Handle cases without scheme? (less likely for http)
        else: scheme_end += 3

        # Find the start of the path (the first '/' after the domain/port)
        path_start = url.find('/', scheme_end)
        if path_start == -1: path_start = len(url) # No path found, use end of string

        # Find the last colon ':' between the scheme end and the path start
        # This should isolate the colon indicating the port number
        last_colon = url.rfind(':', scheme_end, path_start)
        if last_colon == -1: return None # No colon found in the relevant part, so no port

        # Extract the potential port number string
        port_str = url[last_colon + 1 : path_start]

        # Check if the extracted string consists only of digits
        if port_str.isdigit():
            return port_str # Return the port number as a string
        else:
            return None # Extracted part wasn't purely digits
    except Exception:
        # Catch any unexpected errors during string manipulation
        return None

def call_api(x: float, y: float, base_url: str) -> Optional[float]:
    """
    Makes an API GET request to the specified base_url with the given x and y coordinates.
    Expects the API to return a JSON response like {'z': numeric_value}.
    Handles potential network errors, timeouts, bad HTTP status codes, and JSON parsing issues.
    Returns the extracted 'z' value as a float if successful, otherwise returns None.
    """
    # Ensure the base URL ends with a slash '/' before appending coordinates.
    if not base_url.endswith('/'):
        base_url += '/'

    # Construct the full API URL.
    api_url = f"{base_url}{x}/{y}"
    try:
        # Perform the HTTP GET request with a specified timeout.
        response = requests.get(api_url, timeout=TIMEOUT_SECONDS)

        # Check if the response status code indicates an error (e.g., 404 Not Found, 500 Server Error).
        # If so, it raises an HTTPError exception.
        response.raise_for_status()

        # Check if the response body is empty, which might indicate an issue.
        if not response.text:
             print(f"Warning: Received empty response from {api_url}")
             return None

        # Attempt to parse the response text as JSON
        try:
            # Use requests' built-in JSON decoder.
            data = response.json()

            # Validate the structure of the parsed JSON:
            # 1. Is it a dictionary?
            # 2. Does it contain the key 'z'?
            # 3. Is the value associated with 'z' a number (integer or float)?
            if isinstance(data, dict) and 'z' in data and isinstance(data['z'], (int, float)):
                # If validation passes, extract the 'z' value and convert it to float for consistency.
                z = float(data['z'])
                return z
            else:
                # If JSON structure is invalid, log a warning and return None.
                print(f"Warning: JSON response from {api_url} lacks 'z' key or value is not a number. Response Text: '{response.text}'")
                return None

        # Handle cases where the response text is not valid JSON.
        except JSONDecodeError:
            print(f"Warning: Could not parse response as JSON from {api_url}. Response Text: '{response.text}'")
            return None
        # Handle other potential errors during JSON processing (e.g., unexpected data types).
        except Exception as e:
            print(f"Warning: Error processing JSON response from {api_url}: {e}. Response Text: '{response.text}'")
            return None

    # Handle request timeout errors.
    except requests.exceptions.Timeout:
        print(f"Warning: Timeout calling {api_url}")
        return None
    # Handle other request-related errors (connection errors, DNS issues, HTTP errors caught by raise_for_status).
    except requests.exceptions.RequestException as e:
        print(f"Warning: API call failed for {api_url}: {e}")
        return None
    # Handle any other unexpected errors that might occur during the API call process.
    except Exception as e:
        print(f"Warning: An unexpected error occurred calling {api_url}: {e}")
        return None

def find_nearest_explored(target_coord: Coord, explored_data: List[ExploredPoint]) -> Optional[ExploredPoint]:
    """
    Finds the point in the `explored_data` list that is geographically closest
    (using Euclidean distance) to the `target_coord`.
    Used during exploitation to estimate the value of potential next steps based on exploration findings.
    Returns the full (x, y, z) tuple of the nearest explored point, or None if `explored_data` is empty.
    """
    # If there's no exploration data, we can't find a nearest point.
    if not explored_data:
        return None

    # Initialize minimum distance squared to infinity (ensuring first point becomes the closest initially).
    # Using squared distance avoids the need for math.sqrt, which is computationally slightly more expensive
    # and doesn't change the outcome of finding the *closest* point.
    min_dist_sq = float('inf')
    # Initialize the nearest point found so far.
    nearest_point = None

    # Unpack the target coordinates (x, y).
    tx, ty = target_coord

    # Iterate through each point recorded during exploration.
    for point in explored_data:
        # Unpack the coordinates and value (z) of the explored point.
        ex, ey, ez = point
        # Calculate the squared Euclidean distance between the target and the explored point.
        dist_sq = (ex - tx)**2 + (ey - ty)**2
        # If this point is closer than the closest found so far...
        if dist_sq < min_dist_sq:
            # Update the minimum distance squared.
            min_dist_sq = dist_sq
            # Update the nearest point.
            nearest_point = point

    # Return the closest point found (or None if the input list was empty).
    return nearest_point

def clamp(value: int, min_val: int, max_val: int) -> int:
    """
    Clamps an integer `value` to be within the inclusive range [`min_val`, `max_val`].
    Useful for ensuring exploitation coordinates stay within the allowed [-100, 100] boundaries.
    """
    # Return the maximum of min_val and (the minimum of value and max_val).
    # This effectively caps the value at both ends of the range.
    return max(min_val, min(value, max_val))

def run_exploration(base_url: str) -> Tuple[List[ExploredPoint], List[Coord]]:
    """
    Performs the exploration phase by making `EXPLORE_STEPS` API calls
    with random float coordinates within the defined X/Y boundaries.
    Stores the results (x, y, z) of successful calls and logs the (x, y) coordinates used.
    Returns a tuple containing:
        - explored_data: A list of (x, y, z) tuples for successful calls.
        - explore_log: A list of (x, y) tuples for all attempted coordinates that yielded a result.
    """
    print(f"--- Starting Exploration ({EXPLORE_STEPS} steps) ---")
    # List to store successful exploration results: (x, y, z).
    explored_data: List[ExploredPoint] = []
    # List to log the (x, y) coordinates used for exploration (for the CSV file).
    explore_log: List[Coord] = []
    # Counter for successful API calls during exploration.
    successful_calls = 0

    # Loop for the specified number of exploration steps.
    for i in range(EXPLORE_STEPS):
        # Generate random floating-point coordinates within the defined exploration range.
        x = random.uniform(X_MIN, X_MAX)
        y = random.uniform(Y_MIN, Y_MAX)

        # Print progress update to the console. '\r' moves the cursor to the beginning
        # of the line, so the next print overwrites it, creating a dynamic status line.
        print(f"Explore Step {i+1}/{EXPLORE_STEPS}: Calling API for ({x:.4f}, {y:.4f})... Successful: {successful_calls}", end='\r')

        # Call the API with the generated coordinates.
        z = call_api(x, y, base_url)

        # Check if the API call was successful (returned a non-None value).
        if z is not None:
            # Store the successful result (x, y, z).
            explored_data.append((x, y, z))
            # Log the coordinates used for this successful call.
            explore_log.append((x, y))
            # Increment the success counter.
            successful_calls += 1
        else:
             # API call failed (timeout, error, bad response, etc.).
             # An error/warning message was already printed by call_api.
             # Optionally, one could add a small delay here if failures are frequent.
             # time.sleep(0.1)
             pass # Continue to the next exploration step.

        # Optional short delay to be polite to the server, preventing overwhelming it.
        # time.sleep(0.01)

    # Print a final status message after the loop finishes. '\n' ensures it's on a new line.
    print(f"\nExploration finished. {successful_calls}/{EXPLORE_STEPS} API calls successful. Found {len(explored_data)} data points.")
    # Return the collected data and the log of coordinates used.
    return explored_data, explore_log

def run_exploitation(base_url: str, explored_data: List[ExploredPoint]) -> Tuple[List[IntCoord], float]:
    """
    Performs the exploitation phase based on the results from `run_exploration`.
    Starts at the integer coordinates nearest to the best point found during exploration.
    Takes `EXPLOIT_STEPS` connected steps (moving +/-1 in x and/or y), aiming to maximize the sum of Z values.
    Prioritizes moving to unvisited integer coordinates within the exploitation path.
    If all neighbours are visited, it chooses the visited neighbour with the best estimated Z value (based on exploration data).
    Returns a tuple containing:
        - exploitation_moves_log: A list of (int x, int y) tuples representing the actual path taken.
        - total_exploitation_sum: The sum of Z values collected during the exploitation steps.
    """
    print(f"--- Starting Exploitation ({EXPLOIT_STEPS} steps) ---")

    # List to store the sequence of integer coordinates visited during exploitation.
    exploitation_path: List[IntCoord] = []
    # List identical to exploitation_path, specifically for writing to the moves CSV file.
    exploitation_moves_log: List[IntCoord] = []
    # Variable to accumulate the sum of Z values obtained during exploitation.
    total_exploitation_sum = 0.0

    # If exploration yielded no data, exploitation is impossible.
    if not explored_data:
        print("Error: No data collected during exploration. Cannot perform exploitation.")
        return exploitation_moves_log, total_exploitation_sum

    # 1. Find the best point (highest Z value) discovered during the exploration phase.
    # `max()` with a `key` lambda function finds the element with the maximum value based on the 3rd element (index 2, which is Z).
    # `default=None` handles the (unlikely) case where explored_data might be empty even after the initial check.
    best_explored_point = max(explored_data, key=lambda p: p[2], default=None)

    # If no best point could be determined (e.g., explored_data was somehow empty).
    if best_explored_point is None:
         print("Error: Could not find a best point in exploration data.")
         return exploitation_moves_log, total_exploitation_sum

    # Unpack the coordinates and Z value of the best explored point.
    best_ex, best_ey, best_ez = best_explored_point
    print(f"Best explored point: ({best_ex:.4f}, {best_ey:.4f}) with Z = {best_ez:.4f}")

    # 2. Determine the starting integer coordinates for exploitation.
    # Round the best explored float coordinates to the nearest integers.
    # Clamp the rounded values to ensure they are within the strict integer boundaries [-100, 100].
    start_x = clamp(int(round(best_ex)), INT_X_MIN, INT_X_MAX)
    start_y = clamp(int(round(best_ey)), INT_Y_MIN, INT_Y_MAX)
    # Set the starting position for the exploitation walk.
    current_pos: IntCoord = (start_x, start_y)

    print(f"Starting exploitation at integer coordinates: {current_pos}")

    # 3. Perform the exploitation walk for EXPLOIT_STEPS (e.g., 10) steps.
    for step in range(EXPLOIT_STEPS):
        print(f"Exploit Step {step+1}/{EXPLOIT_STEPS}: Current position {current_pos}...", end=' ')

        # a. Make the API call for the *current integer* position.
        # The API expects float/double inputs, so convert the integers back to floats for the call.
        z_current = call_api(float(current_pos[0]), float(current_pos[1]), base_url)

        # Check if the API call during an exploitation step failed.
        if z_current is None:
            print(f"\nCritical Error: API call failed for exploitation step {step+1} at {current_pos}. Aborting exploitation.")
            # If we can't get a value, we cannot reliably continue the path. Stop here.
            # The final sum will include only the values collected up to this point.
            # The moves log will reflect the actual number of steps successfully taken.
            break # Exit the exploitation loop.

        # If the API call was successful, print the received Z value.
        print(f"Received Z = {z_current:.4f}")

        # b. Record the current position to the path/log and add the obtained Z value to the total sum.
        # The path tracks the sequence of visited cells.
        exploitation_path.append(current_pos)
        # The log is used for the CSV output.
        exploitation_moves_log.append(current_pos)
        # Accumulate the score.
        total_exploitation_sum += z_current

        # c. Check if this was the last step (index EXPLOIT_STEPS - 1).
        # If so, we have visited 10 points and don't need to decide on a next move.
        if step == EXPLOIT_STEPS - 1:
            break # Exit the loop after the 10th step's API call and logging.

        # d. Decide the *next* step to take.
        # Initialize the variable to hold the chosen next position.
        best_next_pos: Optional[IntCoord] = None
        # Dictionary to store the estimated Z value for each potential neighbour. Keys are IntCoord, values are float estimates.
        neighbour_estimates: Dict[IntCoord, float] = {}
        # List to store valid neighbour coordinates.
        valid_neighbours: List[IntCoord] = []

        # Iterate through all 8 possible move directions (dx, dy from -1 to 1, excluding 0,0).
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                # Skip the case where dx and dy are both 0 (staying in the same place).
                if dx == 0 and dy == 0:
                    continue # We must move according to the rules.

                # Calculate the coordinates of the potential neighbour.
                next_x = current_pos[0] + dx
                next_y = current_pos[1] + dy

                # Check if the neighbour's coordinates are within the allowed integer boundaries.
                if INT_X_MIN <= next_x <= INT_X_MAX and INT_Y_MIN <= next_y <= INT_Y_MAX:
                    # If within bounds, it's a valid potential neighbour.
                    neighbour_coord = (next_x, next_y)
                    valid_neighbours.append(neighbour_coord)

                    # Estimate the Z value of this neighbour using exploration data.
                    # Find the explored point closest to this neighbour's coordinates.
                    nearest_explored = find_nearest_explored(neighbour_coord, explored_data)
                    # Initialize estimate to negative infinity (a very poor value).
                    # This handles cases where no explored point is reasonably close, making the neighbour unattractive.
                    estimated_z = -float('inf')
                    if nearest_explored:
                        # If a nearest explored point was found, use its Z value as the estimate.
                        estimated_z = nearest_explored[2] # Index 2 is the Z value.
                    # Store the estimate for this neighbour.
                    neighbour_estimates[neighbour_coord] = estimated_z

        # Check if there are any valid neighbours found (e.g., not trapped in a corner against the boundary).
        if not valid_neighbours:
             print(f"\nWarning: No valid neighbours found at {current_pos} within bounds [{INT_X_MIN},{INT_X_MAX}],[{INT_Y_MIN},{INT_Y_MAX}]. Cannot continue path.")
             # If stuck, we cannot make further moves. Break the loop.
             break

        # --- Separate neighbours into visited and unvisited based on the current exploitation path ---
        # List to hold neighbours not yet visited in this exploitation sequence.
        unvisited_neighbours : List[IntCoord] = []
        # List to hold neighbours that *have* been visited in this exploitation sequence.
        visited_neighbours : List[IntCoord] = []
        # Create a set of the path taken so far for efficient checking (O(1) average lookup).
        current_path_set = set(exploitation_path)

        # Categorize each valid neighbour.
        for neighbour in valid_neighbours:
            if neighbour in current_path_set:
                visited_neighbours.append(neighbour)
            else:
                unvisited_neighbours.append(neighbour)

        # --- Prioritized Decision Logic ---

        # 1. Prefer moving to the best *unvisited* neighbour.
        if unvisited_neighbours:
            best_unvisited_z = -float('inf') # Track the best estimate found among unvisited neighbours.
            candidate_pos = None # Store the coordinate of the best unvisited neighbour.
            # Iterate through all unvisited neighbours.
            for neighbour in unvisited_neighbours:
                # If this neighbour's estimated Z is better than the best found so far...
                if neighbour_estimates[neighbour] > best_unvisited_z:
                    # Update the best estimate.
                    best_unvisited_z = neighbour_estimates[neighbour]
                    # Update the candidate position.
                    candidate_pos = neighbour
            # After checking all unvisited neighbours, candidate_pos holds the best one.
            best_next_pos = candidate_pos
            print(f"  -> Chose unvisited neighbour {best_next_pos} (Est. Z: {best_unvisited_z:.4f})")

        # 2. If *all* valid neighbours have already been visited, choose the best *visited* neighbour.
        # This allows backtracking or moving within a known good area if trapped or if all exits look poor.
        elif visited_neighbours:
            best_visited_z = -float('inf') # Track the best estimate found among visited neighbours.
            candidate_pos = None # Store the coordinate of the best visited neighbour.
            # Iterate through all visited neighbours.
            for neighbour in visited_neighbours:
                # If this neighbour's estimated Z is better than the best found so far...
                 if neighbour_estimates[neighbour] > best_visited_z:
                     # Update the best estimate.
                     best_visited_z = neighbour_estimates[neighbour]
                     # Update the candidate position.
                     candidate_pos = neighbour
            # After checking all visited neighbours, candidate_pos holds the best one.
            best_next_pos = candidate_pos # Set the next position (allows revisiting).
            print(f"  -> All neighbours visited. Chose visited neighbour {best_next_pos} (Est. Z: {best_visited_z:.4f})")

        else:
             # This case should theoretically not be reachable if valid_neighbours was not empty.
             # It implies there were valid neighbours, but they were neither visited nor unvisited, which is impossible.
             print(f"\nError: Logic error in neighbour selection. No best next position found.")
             break # Abort if this unexpected state occurs.


        # Defensive check: Ensure a next position was actually selected.
        if best_next_pos is None:
             print(f"\nCritical Error: Failed to select a next step from {current_pos}. Aborting.")
             break # Abort if no next step was chosen.

        # e. Update the current position for the *next* iteration of the loop.
        current_pos = best_next_pos
        # Optional delay between exploitation steps.
        # time.sleep(0.05)

    # After the loop finishes (either by completing 10 steps or breaking early).
    # The exploitation_moves_log contains the actual path taken.
    print(f"\nExploitation finished. Logged {len(exploitation_moves_log)} steps.")

    # Return the log of moves made and the total sum collected.
    return exploitation_moves_log, total_exploitation_sum

def write_csv(filename: str, data: List[Tuple]):
    """
    Writes the provided data (a list of tuples) to a CSV file with the given filename.
    Handles potential file I/O errors.
    Formats float coordinates to a fixed precision for the exploration log.
    """
    try:
        # Open the file in write mode ('w'). `newline=''` prevents extra blank rows in the CSV.
        with open(filename, 'w', newline='') as csvfile:
            # Create a CSV writer object.
            writer = csv.writer(csvfile)
            # Check if there is data to write.
            if data:
                 # Check the type of the first element in the first tuple to determine formatting.
                 if isinstance(data[0][0], float): # Likely exploration log (float coords)
                     # Format float coordinates to 8 decimal places for consistency.
                     formatted_data = [(f"{x:.8f}", f"{y:.8f}") for x, y in data]
                 else: # Likely exploitation log (int coords)
                     # Integer coordinates don't need special formatting.
                     formatted_data = data
                 # Write all formatted rows to the CSV file.
                 writer.writerows(formatted_data)
            else:
                 # If data list is empty, do nothing (or could write a header row if desired).
                 pass
        # Print success message after closing the file.
        print(f"Successfully wrote {len(data)} rows to {filename}")
    # Handle errors related to file operations (e.g., permission denied).
    except IOError as e:
        print(f"Error writing file {filename}: {e}")
    # Handle any other unexpected errors during file writing.
    except Exception as e:
        print(f"An unexpected error occurred writing {filename}: {e}")

# This code runs only when the script is executed directly (not imported as a module).
if __name__ == "__main__":
    # Set up the command-line argument parser.
    parser = argparse.ArgumentParser(description="Explore and Exploit a 2D API environment.")
    # Add required argument for the base API URL.
    parser.add_argument("base_url", help="Base URL of the API (e.g., http://157.180.73.240:8080)")

    # Parse the arguments provided when running the script.
    args = parser.parse_args()

    # Print header and student names.
    print("--- Final Group Task - Explore and Exploit ---")
    print("Students:")
    print("Kristers, Anton")
    print("--------------------------------------------")

    # Get the base URL from the parsed arguments.
    base_url = args.base_url
    # Extract the port number from the URL for naming output files.
    port = get_port_from_url(base_url)

    # If port extraction failed, use a default name and print a warning.
    if port is None:
        print(f"Warning: Could not automatically determine port from URL '{base_url}'. Using 'unknown_port' for filenames.")
        port = "unknown_port"
        # Depending on requirements, could exit here: exit(1)

    # Construct the filenames for the output CSV files using the extracted port.
    explore_filename = f"explore_{port}.csv"
    moves_filename = f"moves_{port}.csv"

    # --- Run Workflow ---
    # 1. Run the exploration phase.
    explored_data, explore_log = run_exploration(base_url)

    # 2. Write the exploration log to its CSV file.
    if explore_log:
        write_csv(explore_filename, explore_log)
    else:
        print("Warning: No exploration data logged.")


    # 3. Run the exploitation phase *only if* exploration yielded some data.
    if explored_data:
        # Pass the exploration results to the exploitation function.
        exploitation_moves, final_sum = run_exploitation(base_url, explored_data) # Uses the revised function

        # 4. Write the exploitation moves log to its CSV file.
        if exploitation_moves:
            write_csv(moves_filename, exploitation_moves)
            # Print the final results (total sum) to the console.
            print(f"\n--- Final Result for API on Port {port} ---")
            # Use sufficient precision for the final sum display.
            print(f"Total sum from {len(exploitation_moves)} exploitation steps: {final_sum:.8f}")
            print("--------------------------------------------")
        else:
            # Handle case where exploitation ran but produced no moves (e.g., immediate API failure).
            print("Warning: No exploitation moves made or logged.")
            print(f"\n--- Final Result for API on Port {port} ---")
            print(f"Total sum from exploitation steps: 0.0")
            print("--------------------------------------------")

    else:
        # If exploration failed to gather data, skip exploitation entirely.
        print("\nSkipping exploitation due to lack of exploration data.")
        print(f"\n--- Final Result for API on Port {port} ---")
        print(f"Total sum from exploitation steps: 0.0") # Final sum is 0 if exploitation didn't run.
        print("--------------------------------------------")


# Used AI to help guide us in choosing and developing the best algorithm; used it for writing additional
# comments and the "readme" part we submitted in ORTUS
# Gemini 2.5 Pro seems like an absoloute beast, very capable